%!TEX root = ../Demo.tex
\chapter{测试内容}\label{cha:realwork}

本章内容为测试结果、测试过程中发现的问题、以及如何修复（部分）这些问题。表 \ref{tab:testerrorlist} 中为本章概要，经过 \ref{sec:ohloop} 节、\ref{sec:usefulf} 节和 \ref{sec:hopcroft} 节的修改后， FIRE engine 中的最小化算法才能顺利执行。

\begin{table}[!htbp]
    \caption{本章内容概要}
    \label{tab:testerrorlist}
    \centering
    \small% fontsize
    \setlength{\tabcolsep}{6pt}% column separation
    \renewcommand{\arraystretch}{1.2}%row space 
    %\begin{tabular}{lcrr} 
        \begin{tabular}{l l p{4em}<{\centering} p{5em}<{\centering} p{3em}<{\centering}}
        \toprule %\hline 
        函数 & 运行结果 & 是否修复 & 内容 & 位置 \\
        \midrule%\hline
        DFA::min\_Watson() & 函数进入无限循环 & 是 & 分析并修复   & \ref{sec:ohloop} \\
        DFA::usefulf()     & 函数运行中止     & 是 & 分析并修复   & \ref{sec:usefulf} \\
        DFA::min\_Hopcroft() & 函数运行中止   & 是 & 分析并修复   & \ref{sec:hopcroft} \\
        最小化算法运行结果汇总   & --------------   & -- & ------ & \ref{sec:listall}  \\
        DFA::min\_Hopcroft()& 函数功能异常   & 是 & 分析并修复    &  \ref{sec:fixHopcroft} \\
        \bottomrule%\hline 
    \end{tabular}
\end{table}

% \begin{remark}
%     因为$DFA$的最小化建立在状态等价性的基础之上，所以本文并未专门针对等价性进行测试。    
% \end{remark}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{如何测试}

以图 \ref{fig:DFA1} 中的 DFA 为例，按照附录代码 \ref{lst:DFASample} 所示，实例化一个类 DFA 的对象之后，通过执行最小化函数，观察他们的输出结果，列出转移函数，绘制自动机状态转移图。对比输入输出结果以得出结论。FIRE engine 中需要测试的五个最小化算法如表 \ref{tab:listMinAl} 所示。（表 \ref{tab:listMinAl} 中，Final-useful FA 可以通过执行类 DFA 的成员函数 DFA::usefulf() 得到）

\begin{table}[!htbp]
    \caption{Fire engine 中的五个最小化算法}
    \label{tab:listMinAl}
    \centering
    \small% fontsize
    \setlength{\tabcolsep}{6pt}% column separation
    \renewcommand{\arraystretch}{1.2}%row space 
    %\begin{tabular}{lcrr} 
        \begin{tabular}{l c }
        \toprule %\hline 
        算法 & 是否需要 Final-useful FA  \\
        \midrule%\hline
        DFA::min\_Brzozowski()     & 否 \\
        DFA::min\_Hopcroft()       & 是 \\
        DFA::min\_HopcroftUllman() & 是 \\ 
        DFA::min\_dragon()         & 是 \\
        DFA::min\_Watson()         & 是 \\
        \bottomrule%\hline 
    \end{tabular}
\end{table}

\begin{example}
    最小化函数执行示例如下
\begin{lstlisting}
    // 实例化 DFA 的对象(附录代码 C.1) ，得到 "dfa1"
    dfa1.usefulf();
    dfa1.min_Hopcroft();
    std::cout << dfa1 << std::endl;
\end{lstlisting}
\end{example}

% DFA::min\_Brzozowski()   
% DFA::min\_Hopcroft()
% DFA::min\_HopcroftUllman()   
% DFA::min\_dragon()
% DFA::min\_Watson()




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{无限循环}\label{sec:ohloop}

实例化一个如表 \ref{tab:DFA4} 的 DFA 的对象之后，调用函数 DFA::min\_Watson()。（表 \ref{tab:DFA4} 对应的状态转移图为图 \ref{fig:DFA4_0}，含有陷阱状态 $q_5$ ）

\begin{table}[!htbp]
    \caption{接受{$\mathcal{L}=0^*10^*$}的自动机{\cite{book1}}}
    \label{tab:DFA4}
    \centering
    \small% fontsize
    \setlength{\tabcolsep}{4pt}% column separation
    \renewcommand{\arraystretch}{1.2}%row space 
    %\begin{tabular}{lcrr} 
        \begin{tabular}{l p{3em}<{\centering} p{3em}<{\centering} p{3em}<{\centering}}
        \toprule %\hline 
        \multirow{2}{*}{状态说明} & \multirow{2}{*}{状态} & \multicolumn{2}{c}{输入字符} \\
		\cline{3-4}      &    &$0$ & $1$  \\
        \midrule%\hline
        开始状态(start)  & $q_0$ & $q_1$   & $q_2$   \\
                        & $q_1$ & $q_0$   & $q_3$   \\
        结束状态(final) & $q_2$ & $q_4$   & $q_5$   \\
        结束状态(final) & $q_3$ & $q_4$   & $q_5$   \\
        结束状态(final) & $q_4$ & $q_4$   & $q_5$   \\
        陷阱状态(sink) & $q_5$ & $q_5$   & $q_5$   \\
        \bottomrule%\hline 
    \end{tabular}
\end{table}

% {\bfseries 运行结果：} 函数进入无限循环
\subsection{运行结果}
函数进入无限循环。

% {\bfseries 错误原因：}
\subsection{错误原因} 

单步调试发现进入无限循环的位置为min-bww.cpp（124行），为代码 \ref{lst:minbww} 中的“H.equivalize(p, q);”。

\begin{lstlisting}[language=C++,label={lst:minbww},caption={min-bww.cpp}]
if (are_eq(p, q, S, H, Z))
{
    // p and q are equivalent.
    H.equivalize(p, q);
}
\end{lstlisting}
单步进入该函数，可以看到代码 \ref{lst:StateEqRel} （StateEqRel.cpp（42行））

\begin{lstlisting}[language=C++,label={lst:StateEqRel},caption={StateEqRel.cpp}]
for (oldq->iter_start(i); !oldq->iter_end(i); oldq->iter_end(i))
{
    map(i) = newp;
}
\end{lstlisting}
for循环的一般格式如代码 \ref{lst:for}

\begin{lstlisting}[language=C++,label={lst:for},caption={for 循环的一般格式}]
for (初始化循环变量; 循环条件; 迭代)
{
    循环体
}
\end{lstlisting}
在代码 \ref{lst:StateEqRel} 中循环变量为“i”，循环条件为“!oldq->iter\_end(i);”，迭代为“oldq->iter\_end(i)”。查看“iter\_end()”函数实现如代码 \ref{lst:itend}

\begin{lstlisting}[language=C++,label={lst:itend},caption={函数 iter\_end() 的实现}]
// StateSet.h
// Is r the last State in an iteration sequence.
inline int StateSet::iter_end(State r) const
{
	return(BitVec::iter_end(r));
}

// BitVec.h
// Is r the last set bit in an iteration sequence.
// if (r== -1) retrun 1; else return 0
inline int BitVec::iter_end(int r) const
{
	return(r == -1);
}
\end{lstlisting}
可以看到函数“iter\_end()”并未对参数“i”进行更改。于是程序在此处进入无限循环。

% {\bfseries 解决方法} :
\subsection{解决方法}

将代码 \ref{lst:StateEqRel} 中的迭代 “oldq->iter\_end(i)” 更改为 “oldq->iter\_next(i)”，更改后如代码 \ref{lst:StateEqRel2} ，经过比对，更改后与原文 \cite{watson1994design} 相同。

\begin{lstlisting}[language=C++,label={lst:StateEqRel2},caption={StateEqRel.cpp}]
for (oldq->iter_start(i); !oldq->iter_end(i); oldq->iter_next(i))
{
    map(i) = newp;
}
\end{lstlisting}

{\bfseries 更改后}：函数“DFA::min\_Watson();”不再陷入无限循环。


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{函数 DFA::usefulf() 运行错误}\label{sec:usefulf}

“DFA::usefulf()” 函数为一个重要函数。用于去除有限自动机中的非 “final-reachable” 状态，在执行最小化算法前执行该函数，可以去除有限自动机中的非“final-reachable”状态，进而减少程序运行时间。其定义如代码 \ref{lst:usefulf}

\begin{lstlisting}[language=C++,label={lst:usefulf},caption={DFA::usefulf()}]
// Remove any States that cannot reach a final State.
// (This is a last step in minimization, since some of the min. algorithms may yield a DFA with a sink state.)
// Implement Remark 2.39  removing states that are not final - reachable.
DFA& usefulf();
\end{lstlisting}
以图 \ref{fig:DFA4_0} 为例，状态$q_5$ 即为非 “final-reachable” 状态（下称陷阱状态）。移除状态 $q_5$ 之后如图 \ref{fig:DFA4_1} 。图 \ref{fig:DFA4_1} 转移函数如表 \ref{tab:DFA4_1}。

\begin{table}[!htbp]
    \caption{接受{$\mathcal{L}=0^*10^*$}的自动机{\cite{book1}}}
    \label{tab:DFA4_1}
    \centering
    \small% fontsize
    \setlength{\tabcolsep}{4pt}% column separation
    \renewcommand{\arraystretch}{1.2}%row space 
    %\begin{tabular}{lcrr} 
        \begin{tabular}{l p{4em}<{\centering} p{3em}<{\centering} p{3em}<{\centering}}
        \toprule %\hline 
        \multirow{2}{*}{状态说明} & \multirow{2}{*}{状态} & \multicolumn{2}{c}{输入字符} \\
		\cline{3-4}      &    &$0$ & $1$  \\
        \midrule%\hline
        开始状态(start)  & $q_0$ & $q_1$   & $q_2$   \\
                        & $q_1$ & $q_0$   & $q_3$   \\
        结束状态(final) & $q_2$ & $q_4$   & -   \\
        结束状态(final) & $q_3$ & $q_4$   & -   \\
        结束状态(final) & $q_4$ & $q_4$   & -   \\
        \bottomrule%\hline 
    \end{tabular}
\end{table}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% {\bfseries 运行结果}
\subsection{运行结果}

执行函数“DFA::usefulf()”后若状态 $q_5$ 被去除，则函数定义功能正常执行。但是在实际的执行过程中，程序提示如图 \ref{fig::usefulf_error} 错误 

\begin{figure}[!htbp]
    \centering
    \includegraphics[width=0.60\textwidth]{DFA_usefulf_error}
    \caption{函数 DFA::usefulf() 错误提示}
    \label{fig::usefulf_error}
\end{figure}
控制台提示如图 \ref{fig::usefulf_console_log}
\begin{figure}[!htbp]
    \centering
    %trim option's parameter order: left bottom right top
    \includegraphics[trim = 0mm 0mm 0mm 63mm, clip,width=0.95\textwidth]{DFA_usefulf_console_log}
    \caption{函数 DFA::usefulf() 错误提示}
    \label{fig::usefulf_console_log}
\end{figure}

可以确定函数未完成其定义功能。

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% {\bfseries 错误原因}
\subsection{错误原因}

查看 TransImple.cpp，79行，代码如下

\begin{lstlisting}[language=C++,label={lst:TransImple},caption={ TransImple.cpp },firstnumber=75]
// Add a transition to the set.
TransImpl& TransImpl::add_transition(const CharRange a, const State q)
{
    assert(a.class_invariant());
    assert(0 <= q);
    ………
}
\end{lstlisting}

在 79 行处打断点，单步调试至此处，可以看到 State 变量 q 的值为“-842150451”，对应的十六进制值为“0xFFFFFFFF”\footnote{调试时使用 64 位编译器产生的二进制文件，在 64 位系统下运行。}，为常见的未初始化错误。此时表达式 “0 <= q” 不成立，返回值为 “false” , 程序在此处中止。

查看函数 DFA::usefulf() 的实现，如代码 \ref{lst:DFA_usefulf_1} 。

\begin{lstlisting}[language=C++,label={lst:DFA_usefulf_1},caption={ DFA.cpp },firstnumber=84]
StateTo<State> newnames;
newnames.set_domain(Q.size());

// All components will be constructed into a special structure :
DFA_components ret;
State st;
for (st = 0; st < Q.size(); st++)
{
    // If this is a Usefulf State, carry it over by giving it a name
    // in the new DFA.
    if (freachable.contains(st))
    {
        newnames.map(st) = ret.Q.allocate();
    }
}
\end{lstlisting}
在代码 \ref{lst:DFA_usefulf_1} 中将 “ final-reachable ” 状态保存到 StateTo<State> 变量 newnames 中，通过 “ ret.Q.allocate()” 为状态命名新的状态名，作为新的自动机的状态名。DFA\_components 变量 ret 用于构建新的自动机，再看函数内构造新的自动机的主要实现部分，如代码 \ref{lst:DFA_usefulf_2}

\begin{lstlisting}[language=C++,label={lst:DFA_usefulf_2},caption={ DFA.cpp },firstnumber=130]
for (it = 0; !a.iter_end(it); it++)
{
    b = a.iterator(it);
    ret.T.add_transition(stprime, b, newnames.lookup(T.transition_on_range(st, b)));
}
\end{lstlisting}

根据代码 \ref{lst:TransImple} ，可以知道程序中止的地方为代码 \ref{lst:DFA_usefulf_2}，133 行。其中 State 变量为当前需要进行操作的状态，CharRange 变量 b 为当前状态转移输入字符。查看 T.
transition\_on\_range(st, b)) 的实现，如代码 \ref{lst:transition_on_range}

\begin{lstlisting}[language=C++,label={lst:transition_on_range},caption={ DTransRel.cpp },firstnumber=108]
// Compute the image of r, and CharRange it under *this.
inline State DTransRel::transition_on_range(const State r, const CharRange a) const
{
    assert(class_invariant());
    assert(0 <= r && r < domain());
    return(lookup(r).range_transition(a));
}
\end{lstlisting}
由代码 \ref{lst:transition_on_range} 可知，T.transition\_on\_range(st, b)) 将返回原自动机中，状态 st 经过输入字符 b 转移之后的目标状态。

查看 newnames.lookup() 的实现，如代码 \ref{lst:newnames-lookup}

\begin{lstlisting}[language=C++,label={lst:newnames-lookup},caption={ StateTo.h },firstnumber=177]
// The actual mapping function
// First, a const lookup operator.
template<class T>
inline const T& StateTo<T>::lookup(const State r) const
{
    assert(class_invariant());
    // First check that it's in bounds
    assert(0 <= r && r < domain());
    return(data[r]);
}
\end{lstlisting}
在本例中，模板类 StateTo<T> 的模板参数 “T” 为 State。则 newnames.lookup(T.transition\_on\_range(st, b)) 为原自动机中 状态 st 经过字符 b 转移后的目标状态在新自动机中的状态。然后通过 ret.T.add\_transition() 保存新的转移关系。对所有的状态进行以上操作之后，通过变量 ret 构造新的自动机。 

经过单步调试发现，表\ref{tab:DFA4} 中，状态 $q_2$ 经过字符 “1” 将转移到状态 $q_5$，而在代码 \ref{lst:DFA_usefulf_1} 中，状态 $q_5$ 不满足 “if (freachable.contains(st))”，所以状态 $q_5$ 未被新的自动机保存，进而在代码 \ref{lst:DFA_usefulf_2} 中，当 st 为状态 $q_2$ 且 b 为字符 “1” 时，“newnames.lookup(T.transition\_on\_range(st, b))” 将返回未经初始化的值“-842150451”，于是在代码 \ref{lst:TransImple} 中，State 变量 q 的值为“-842150451”，导致程序在此处中止。

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{解决方法}

如代码 \ref{lst:State_H} 所示，文件 State.h 中将无效状态设置为 “Invalid”。在代码 \ref{lst:DFA_usefulf_1}增加处理不满足条件 “freachable.contains(st)” 的状态的内容，将原自动机中的非“final-reachable”状态标记为 “Invalid”，更改后为代码 \ref{lst:DFA_usefulf_1_edit}

\begin{lstlisting}[language=C++,label={lst:DFA_usefulf_1_edit},caption={ 更改后的 DFA.cpp },firstnumber=91]
for (st = 0; st < Q.size(); st++)
{
    // If this is a Usefulf State, carry it over by giving it a name
    // in the new DFA.
    if (freachable.contains(st))
    {
        newnames.map(st) = ret.Q.allocate();
    }
    else                            // 新增
    {                               // 新增
        newnames.map(st) = Invalid; // 新增
    }                               // 新增
}
\end{lstlisting}

在代码 \ref{lst:DFA_usefulf_2} 中，在添加新的转移关系之前判断当前状态和目标状态是否都是有效状态，若都为有效状态，则添加新的转移关系。更改后为代码 \ref{lst:DFA_usefulf_2_edit}

\begin{lstlisting}[language=C++,label={lst:DFA_usefulf_2_edit},caption={ 更改后的 DFA.cpp },firstnumber=133]
    State stdest;                                           // 新增
    stdest = newnames.lookup(T.transition_on_range(st, b)); // 新增

    if (stprime != Invalid &&  stdest != Invalid)           // 新增
    {                                                       // 新增
        ret.T.add_transition(stprime, b, stdest));          // 修改
    }                                                       // 新增
\end{lstlisting}

更改后函数 DFA::usefulf() 成功移除图 \ref{fig:DFA4_0} 中的陷阱状态 $q_5$ ，将图 \ref{fig:DFA4_0} 转换成图 \ref{fig:DFA4_1}。
更改后函数 DFA::usefulf() 成功移除图 \ref{fig:usefulf2-1} 中的陷阱状态 $q_1$ ，将图 \ref{fig:usefulf2-1} 转换成图 \ref{fig:usefulf2-2} 。



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{函数 DFA::min\_Hopcroft() 运行错误}\label{sec:hopcroft}

% Hopcroft 算法描述如下\cite{watson1993taxonomyb} \\
% {\small \setlength{\parskip}{1em}
% \rule{\textwidth}{1pt}
% \mbox{　} $P:=[Q]_{E_0}$; \\
% \mbox{　} $L:= ( \mbox{\textbf{if }} ( |F| \leq |Q \setminus F | ) \mbox{\textbf{then }} \{F\} \mbox{\textbf{else }} \{ Q \setminus F \} \mbox{\textbf{fi }} ) \times V $; \\
% \mbox{　} $ \{ \mbox{恒有: } [Q]_E \sqsubseteq P \sqsubseteq [Q]_{E_0} \land L \subseteq (P \times V) $ \\
% \mbox{　　　} $ \land (\forall Q_0,Q_1,a:Q_0 \in Q \land (Q_1,a) \in L : \neg Splittable (Q_0,Q_1,a)) \Rightarrow (P=[Q]_E) \} $ \\
% \mbox{　} $ \mbox{\textbf{do }} L \not= \emptyset \longrightarrow $ \\ 
% \mbox{　　　} $ \mbox{\textbf{let }} Q_1,a:(Q_1,a) \in L $; \\
% \mbox{　　　} $ P_{old} := P $; \\
% \mbox{　　　} $ L := L \setminus \{ (Q_1,a) \} $; \\
% \mbox{　　　} $ \{  \mbox{恒有: } [Q]_E \sqsubseteq P \sqsubseteq P_{old} \} $ \\
% \mbox{　　　} $ \mbox{\textbf{for }} Q_0 : Q_0 \in P_{old} \land Splittable (Q_0,Q_1,a) \mbox{\textbf{ do }} $ \\
% \mbox{　　　　　} $ Q'_0 := \{ p:p \in Q_0 \land T(p,a) \in Q_1 \} $; \\
% \mbox{　　　　　} $ P:= P \setminus \{ Q_0 \} \cup \{ Q_0 \setminus Q'_0,b \} $;\\
% \mbox{　　　　　} $ \mbox{\textbf{for }} b:b \in V \mbox{\textbf{ do }} $ \\
% \mbox{　　　　　　　} $ \mbox{\textbf{if }} (Q_0,b) \in L \rightarrow L := L \setminus \{ (Q_0,b) \} \cup \{ (Q'_0,b),(Q_0, \setminus Q'_0,b ) \} $;\\ 
% \mbox{　　　　　　　} $ \talloblong (Q_0,b) \notin L \rightarrow $ \\
% \mbox{　　　　　　　　　} $ L := L \cup (\mbox{\bfseries if} ( |Q'_0| \leq |Q_0 \setminus Q'_0| ) \mbox{\bfseries then} \{ (Q'_0 , b) \} \mbox{\bfseries else} \{ ( Q'_0 \setminus Q'_0,b ) \} \mbox{\bfseries fi} ) $ \\
% \mbox{　　　　　　　} $ \mbox{\textbf{fi}} $ \\
% \mbox{　　　　　} $ \mbox{\textbf{rof}} $ \\
% \mbox{　　　} $ \mbox{\textbf{rof}} $ \\
% \mbox{　　　} $ \{ (\forall Q_0,Q_0 \in P : \neg Splittable(Q_0,Q_1,a)) \} $ \\
% \mbox{　} $ \mbox{\textbf{od }} \{ P = [Q]_E \} $ \\
% \rule{\textwidth}{1pt} }

实例化如表 \ref{tab:DFA411-1} 所示的自动机。（含有开始不可达状态）

\begin{table}[!htbp]
    \caption{图\ref{fig:DFA11-0}的转移函数}
    \label{tab:DFA411-1}
    \centering
    \small% fontsize
    \setlength{\tabcolsep}{4pt}% column separation
    \renewcommand{\arraystretch}{1.2}%row space 
    %\begin{tabular}{lcrr} 
        \begin{tabular}{l p{4em}<{\centering} p{3em}<{\centering} p{3em}<{\centering}}
        \toprule %\hline 
        \multirow{2}{*}{状态说明} & \multirow{2}{*}{状态} & \multicolumn{2}{c}{输入字符} \\
		\cline{3-4}      &    &$0$ & $1$  \\
        \midrule%\hline
        开始状态(start)  & $q_0$ & $q_1$   & $q_2$   \\
                        & $q_1$ & $q_5$   & $q_2$   \\
                        & $q_2$ & $q_3$   & $q_6$   \\
                        & $q_3$ & $q_2$   & $q_4$   \\
        结束状态(final) & $q_4$ & $q_8$   & $q_1$   \\
                        & $q_5$ & $q_1$   & $q_6$   \\
                        & $q_6$ & $q_7$   & $q_2$   \\
                        & $q_7$ & $q_6$   & $q_8$   \\
        结束状态(final) & $q_8$ & $q_5$   & $q_4$   \\
        开始不可达状态    & $q_9$ & $q_7$   & $q_5$   \\
        \bottomrule%\hline 
    \end{tabular}
\end{table}

函数 DFA::min\_Hopcroft() 是 Hopcroft 算法在 FIRE engine 中的实现，Hopcroft 算法的描述如算法 \ref{al:4-8} 所示\cite{watson1993taxonomyb}

\begin{algorithm}
    \caption{Hopcroft 最小化算法}\label{al:4-8}
    \small
    \begin{algorithmic}[1]
        \State $P:=[Q]_{E_0}$;
        \State $L:= ( \mbox{\textbf{if }} ( |F| \leq |Q \setminus F | ) \mbox{\textbf{then }} \{F\} \mbox{\textbf{else }} \{ Q \setminus F \} \mbox{\textbf{end if }} ) \times V $;
        \State $\{ \mbox{恒有：} [Q]_E \sqsubseteq P \sqsubseteq [Q]_{E_0} \land L \subseteq (P \times V) $
        \State \quad $ \land (\forall Q_0,Q_1,a:Q_0 \in Q \land (Q_1,a) \in L : \neg Splittable (Q_0,Q_1,a)) \Rightarrow (P=[Q]_E) \} $
        \Repeat {$L \not= \emptyset \longrightarrow$}
            \State $ \mbox{\textbf{let }} Q_1,a:(Q_1,a) \in L $;
            \State $ P_{old} := P $;
            \State $ L := L \setminus \{ (Q_1,a) \} $;
            \State $ \{ \mbox{恒有:} [Q]_E \sqsubseteq P \sqsubseteq P_{old} \} $
            \For {$Q_0 : Q_0 \in P_{old} \land Splittable (Q_0,Q_1,a)$}
                \State $ Q'_0 := \{ p:p \in Q_0 \land T(p,a) \in Q_1 \} $;
                \State $ P:= P \setminus \{ Q_0 \} \cup \{ Q_0 \setminus Q'_0,b \} $;
                \For {$b:b \in V$}
                    \If{$(Q_0,b) \in L$}
                       $ L := L \setminus \{ (Q_0,b) \} \cup \{ (Q'_0,b),(Q_0, \setminus Q'_0,b ) \} $
                    \ElsIf{$(Q_0,b) \not\in L$}
                        \State $L:= L \cup ( \mbox{\textbf{if }} ( |Q'_0| \leq |Q_0 \setminus Q'_0 | ) \mbox{\textbf{then }} \{(Q'_0,b)\} \mbox{\textbf{else }} \{ (Q_0 \setminus Q'_0,b) \} \mbox{\textbf{end if }} ) $;
                    \EndIf
                \EndFor
            \EndFor
            \State $ \{ (\forall Q_0,Q_0 \in P : \neg Splittable(Q_0,Q_1,a)) \} $
        \Until $\{ P = [Q]_E \}$
    \end{algorithmic}
\end{algorithm}

% \begin{figure}[!htbp]
%     \centering
%         \includegraphics[trim = 0mm 0mm 0mm 4mm, clip,width=0.99\textwidth]{hopcroft}
%     \caption{ Hopcroft 算法}
%     \label{fig:desHopcroft}
% \end{figure}

\subsection{运行结果}\label{sec:hopcroft-error}
执行函数 DFA::min\_Hopcroft()，程序在文件CRSet.h，第 146 行的 “assert(!iter\_end(it))” 处触发 assert 中止，如代码 \ref{lst:iterend} 所示。调用函数“CRSet::iterator()”的地方为文件min-hop.cpp，第103行，“State r(split(p, q, C.iterator(L[q]), P));”的“C.iterator(L[q])”处。

\begin{lstlisting}[language=C++,label={lst:iterend},caption={ CRSet.h },firstnumber=142]
// Fetch the it'th CharRange in *this.
inline const CharRange& CRSet::iterator(const int it) const
{
    assert(class_invariant());
    assert(!iter_end(it));
    return(data[it]);
}

// Is there even in it'th CharRange?
inline int CRSet::iter_end(const int it) const
{
    assert(class_invariant());
    assert(0 <= it);
    return(it >= in_use);
}
\end{lstlisting}

\subsection{错误原因}

以表 \ref{tab:DFA411-1} 中实例化的自动机为例，CRSet 变量 C = \{ 0, 1\}，在程序中止处打断点，调试至此处可看到 int 变量 it 为 “2”，因 C 中只有两个值 “0，1”，所以传入参数为 “2” 时，超出了 C 的范围（数组从 0 开始计数），于是在语句 “assert(!iter\_end(it));” 处导致程序中止。

表 \ref{tab:DFA411-1} 所示的自动机在 DFA::min\_Hopcroft 算法中迭代过程如附录表 \ref{tab:hopcroft} 所示。

在第 11 次迭代中，DFA::split() 函数将等价类\{0,1,5\} 分割为等价类 \{\{0\},\{1,5\}\}，此时$p=0,q=0,r=1$，满足条件$|Q'_0| \leq | Q_0 \setminus Q'_0 |$，执行 L[r] = L[p] =1，L[p] = C.size() = 2。在第 12 次迭代中，由于第 11 次迭代中 $p=q$ ，所以 L[q] 的值将被更改为 “2”，于是在 C.iterator(L[q]) 处传入一个超过 C 的范围的值，程序触发 assert 中止。

\subsection{解决方法}

函数 DFA::min\_Hopcroft() 的主要实现部分如代码 \ref{lst:hopcroft-iter}。

\begin{lstlisting}[language=C++,label={lst:hopcroft-iter},caption={ min-hop.cpp },firstnumber=100]
    for (repr.iter_start(p); !repr.iter_end(p); repr.iter_next(p))
    {
        //分割等价类
        ……
    }
\end{lstlisting}

在分割等价类之前，判断 L[q] 是否等于 “C.size()”，若是，则减去 “1”，更改后为代码 \ref{lst:hopcroft-iter-edit}


\begin{lstlisting}[language=C++,label={lst:hopcroft-iter-edit},caption={ min-hop.cpp },firstnumber=100]
    for (repr.iter_start(p); !repr.iter_end(p); repr.iter_next(p))
    {
        if(L[q] == C.size()) // 新增
        {                    // 新增
            L[q]--;          // 新增
        }                    // 新增
        //分割等价类
        ……
    }
\end{lstlisting}

更改后函数 DFA::min\_Hopcroft() 运行不再中止。

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{测试结果汇总}\label{sec:listall}

经过 \ref{sec:ohloop} 节、\ref{sec:usefulf} 节和 \ref{sec:hopcroft} 节的修改，FIRE engine 中的最小化算法及最小化算法用到的帮助函数都可以成功运行。本节内容为测试正确的结果和一些未能解决的问题的汇总。

\subsection{不改变已经是最小的 DFA 接受的语言}

接受同一个 $\mathcal{L}$ 的最小的 DFA 是唯一的，最小的且接受相同 $\mathcal{L}$ 的 DFA 仅仅在状态命名上有差别\cite{book1}。因此最小化算法有性质 \ref{sec:keepMin} 。

\begin{property}\label{sec:keepMin}
    由定义 \ref{def:min} 可知，对于 DFA $M$，$\mathcal{L}(Min(M))= \mathcal{L}(M)$，同样的，最小化算法不能使最小的 DFA 接受的 $\mathcal{L}$ 发生改变。
\end{property}

\begin{remark}
    DFA 中的 开始不可达（start-unreachable）状态和陷阱状态（final-unreachable）状态不影响 DFA 接受的 $\mathcal{L}$。
\end{remark}



\begin{table}[!htbp]
    \caption{一组最小的 DFA}
    \label{tab:KeepMinData}
    \centering
    \small% fontsize
    \setlength{\tabcolsep}{4pt}% column separation
    \renewcommand{\arraystretch}{1.2}%row space 
    \begin{tabular}{c p{4em}<{\centering} p{4em}<{\centering} l}  %l p{3em}<{\centering} p{3em}<{\centering} p{3em}<{\centering}
        \toprule %\hline 
                序号  &  数据 & 属性 & 备注 \\
        \midrule%\hline
        1 &  图 \ref{fig:usefulf2-1} & 最小的 & 含有陷阱状态 \\
        2 &  图 \ref{fig:usefulf2-2} & 最小的 & 不含陷阱状态 \\
       \midrule
        5 & 图 \ref{fig:keepMin-1-unreachable} & 最小的 & 含有开始不可达状态 \\
        6 & 图 \ref{fig:keepMin-1-nonTheState} & 最小的 & 不含开始不可达状态 \\
       \midrule
        7 & 图 \ref{fig:keepMin-2-unreachable} & 最小的 & 含有开始不可达状态 \\
        8 & 图 \ref{fig:keepMin-2-nonTheState} & 最小的 & 不含开始不可达状态 \\
        \midrule
        3 & 图 \ref{fig:DFA11-0} & 最小的 & 含有开始不可达状态 \\
        4 & 图 \ref{fig:DFA11-1} & 最小的 & 不含开始不可达状态 \\
        \bottomrule%\hline  
    \end{tabular}
\end{table}


对于性质 \ref{sec:keepMin} ，以表 \ref{tab:KeepMinData} 中的一组最小的 DFA 为数据，测试结果如表 \ref{tab:KeepMinResult} 所示。




\begin{table}[!htbp]
    \caption{ 最小化算法对性质 \ref{sec:keepMin} 的测试结果 }
    \label{tab:KeepMinResult}
    \centering
    \small% fontsize
    \setlength{\tabcolsep}{4pt}% column separation
    \renewcommand{\arraystretch}{1.2}%row space 
    \begin{tabular}{l|p{2em}<{\centering} p{2em}<{\centering} p{2em}<{\centering} p{2em}<{\centering} p{2em}<{\centering} p{2em}<{\centering} p{2em}<{\centering} p{2em}<{\centering}}  %l p{3em}<{\centering} p{3em}<{\centering} p{3em}<{\centering}
        \toprule %\hline 
        算法 & 1 & 2 & 3 & 4 &  5 &  6  & 7 & 8  \\
        \midrule
        DFA::min\_Brzozowski()        & $\surd$ & $\surd$ & $\times$  & $\times$  & $\checkmark$ & $\surd$ & $\checkmark$ & $\surd$ \\
        DFA::min\_Hopcroft()（修改前） & $\surd$ & $\surd$ & 中止    & $\surd$     & $\surd$ & $\surd$ & $\surd$ & $\surd$ \\
        DFA::min\_Hopcroft()（修改后） & $\surd$ & $\surd$ & $\surd$ & $\surd$     & $\surd$ & $\surd$ & $\surd$ & $\surd$ \\
        DFA::min\_HopcroftUllman()    & $\surd$ & $\surd$ & $\surd$ & $\surd$     & $\surd$ & $\surd$ & $\surd$ & $\surd$ \\
        DFA::min\_dragon()            & $\surd$ & $\surd$ & $\surd$ & $\surd$     & $\surd$ & $\surd$ & $\surd$ & $\surd$ \\
        DFA::min\_Watson()            & $\surd$ & $\surd$ & $\surd$ & $\surd$     & $\surd$ & $\surd$ & $\surd$ & $\surd$ \\
        \bottomrule%\hline  
    \end{tabular}
\end{table}

%对表 \ref{tab:KeepMinResult} 中的测试结果有两个算法需要额外关注—— “DFA::min\_Brzozowski()” 和 “DFA::min\_Hopcroft()”。

结果总结对比如下：
\begin{itemize}
    \item 对于 DFA 中的陷阱状态，可以调用函数 “DFA::usefulf()” 函数去除。表 \ref{tab:KeepMinResult} 中在执行最小化函数之前，除了算法 “DFA::min\_Brzozowski”， 都执行了函数 “DFA::usefulf()”；
    \item 除了算法 “DFA::min\_Brzozowski()” 外，其他最小化算法均不能去除 DFA 中的开始不可达状态（start-unreachable）。数据为第 5 个和第 7 个，以 $\checkmark$ 标示，而不是 $\surd$；
    \item 对于算法 “DFA::min\_Hopcroft()” 的 assert 中止，在发生 assert 中止的第 3 个数据中，含有开始不可达状态，但是作为对照组且含有开始不可达状态的第 5 个和第 7 个数据没有发生 assert 中止，所以本文认为此算法的中止的问题不是 DFA 中开始不可达状态导致；
    \item 对于第 3 个和第 4 个数据，算法 “DFA::min\_Brzozowski()” 改变了 DFA ，输入的 DFA 仅有 10/9 个状态，算法 “DFA::min\_Brzozowski()” 输出了含有数百个状态的自动机。
\end{itemize}



\subsection{最小化功能测试}

本节内容为最小化算法对定义功能的测试，以表 \ref{tab:MinData} 中的数据对五个最小化算法进行测试，结果如表 \ref{tab:MinResult} 所示。

\begin{table}[!htbp]
    \caption{一组 DFA}
    \label{tab:MinData}
    \centering
    \small% fontsize
    \setlength{\tabcolsep}{4pt}% column separation
    \renewcommand{\arraystretch}{1.2}%row space 
    \begin{tabular}{c p{4em}<{\centering} p{4em}<{\centering} c }  %l p{3em}<{\centering} p{3em}<{\centering} p{3em}<{\centering}
        \toprule %\hline 
                序号  &  数据 & 属性 & 预期结果  \\
        \midrule%\hline
        1 &  图 \ref{fig:DFA4_0} &            & 图 \ref{fig:DFA4_3}\\
        \midrule
        2 & 图 \ref{fig:DFAMin-3-0} &         & 图 \ref{fig:DFAMin-3-2}  \\
        3 & 图 \ref{fig:DFAMin-3-1} & 最小的  & 图 \ref{fig:DFAMin-3-1}  \\
        \midrule
        4 & 图 \ref{fig:DFAMin-5-0} &         & 图 \ref{fig:DFAMin-5-2}  \\
        5 & 图 \ref{fig:DFAMin-5-1} & 最小的  & 图 \ref{fig:DFAMin-5-1}  \\
        \midrule
        6 & 图 \ref{fig:DFAMin-4-0} &        & 图 \ref{fig:DFAMin-4-2}  \\
        7 & 图 \ref{fig:DFAMin-4-1} & 最小的  & 图 \ref{fig:DFAMin-4-1}  \\
        \bottomrule%\hline  
    \end{tabular}
\end{table}

\begin{table}[!htbp]
    \caption{ 最小化算法的定义功能的测试结果 }
    \label{tab:MinResult}
    \centering
    \small% fontsize
    \setlength{\tabcolsep}{4pt}% column separation 
    \renewcommand{\arraystretch}{1.2}%row space 
    \begin{tabular}{l| p{2em}<{\centering} p{2em}<{\centering} p{2em}<{\centering} p{2em}<{\centering} p{2em}<{\centering} p{2em}<{\centering} p{2em}<{\centering} }  %l p{3em}<{\centering} p{3em}<{\centering} p{3em}<{\centering}
        \toprule %\hline 
        算法 & 1 & 2 & 3 & 4 &  5 & 6 & 7 \\
        \midrule
        DFA::min\_Brzozowski()        & $\surd$ & $\surd$ & $\surd$   & $\surd$ & $\surd$ & $\surd$     & $\surd$       \\
        DFA::min\_Hopcroft()（修改前） & $\surd$ & $\surd$ & $\times$  & $\surd$ & $\surd$ & 中止        & $\surd$       \\
        DFA::min\_Hopcroft()（修改后） & $\surd$ & $\surd$ & $\times$  & $\surd$ & $\surd$ & $\surd$     & $\surd$       \\
        DFA::min\_HopcroftUllman()    & $\surd$ & $\surd$ & $\surd$   & $\surd$ & $\surd$ & $\surd$     & $\surd$       \\
        DFA::min\_dragon()            & $\surd$ & $\surd$ & $\surd$   & $\surd$ & $\surd$ & $\surd$     & $\surd$       \\
        DFA::min\_Watson()            & $\surd$ & $\surd$ & $\surd$   & $\surd$ & $\surd$ & $\surd$     & $\surd$       \\
        \bottomrule%\hline  
    \end{tabular}
\end{table}

对于第 3 个数据，算法 “DFA::min\_Hopcroft()” 无论是否经过第 \ref{sec:hopcroft} 节的修改，均输出代码 \ref{lst:hoperrorResult} 。

\begin{lstlisting}[language=C++,label={lst:hoperrorResult},caption={ 第 3 个数据在算法 “DFA::min\_Hopcroft()” 中的输出 }]
DFA
Q = [0,2)
S = { 0 }
F = { 1 }
Transitions =
0->{ ['a','b']->1 }
1->{ 'a'->1 }

current = -1
\end{lstlisting}

第 3 个数据的转移函数如表 \ref{tab:sample_3_origin} 所示 ，代码 \ref{lst:hoperrorResult} 的转移函数如表 \ref{tab:sample_3_result} 所示 

% \begin{table}[!htbp]
%     \caption{接受{$\mathcal{L}=0^*10^*$}的自动机{\cite{book1}}}
%     \label{tab:hopcroftErrorResult}
%     \centering
%     \small% fontsize
%     \setlength{\tabcolsep}{4pt}% column separation
%     \renewcommand{\arraystretch}{1.2}%row space 
%     %\begin{tabular}{lcrr} 
%         \begin{tabular}{l p{3em}<{\centering} p{3em}<{\centering} p{3em}<{\centering}}
%         \toprule %\hline 
%         \multirow{2}{*}{状态说明} & \multirow{2}{*}{状态} & \multicolumn{2}{c}{输入字符} \\
% 		\cline{3-4}      &    &$0$ & $1$  \\
%         \midrule%\hline
%         开始状态(start)  & $q_0$ & $q_1$   & $q_2$   \\
%                         & $q_1$ & $q_0$   & $q_3$   \\
%         结束状态(accept) & $q_2$ & $q_4$   & $q_5$   \\
%         结束状态(accept) & $q_3$ & $q_4$   & $q_5$   \\
%         结束状态(accept) & $q_4$ & $q_4$   & $q_5$   \\
%         陷阱状态(sink) & $q_5$ & $q_5$   & $q_5$   \\
%         \bottomrule%\hline 
%     \end{tabular}
% \end{table}

\begin{table}[!htbp]
    \caption{第 3 个数据在算法 “DFA::min\_Hopcroft()” 中的输入输出对比 }
    \label{tab:sample_3}
    \centering
    \small% fontsize
    \setlength{\tabcolsep}{4pt}% column separation
    \renewcommand{\arraystretch}{1.2}%row space 
    \begin{subtable}[t]{0.45\textwidth}
        \centering
        \caption{输入}
        \label{tab:sample_3_origin}
        \begin{tabular}{l p{2em}<{\centering} c c}
            \toprule%\hline
            \multirow{2}{*}{状态说明} & \multirow{2}{*}{状态} & \multicolumn{2}{c}{输入字符} \\
            \cline{3-4}      &    &$a$ & $b$  \\
            %\cline{2-9}% partial hline from column i to column j
            \midrule%\hline
            开始状态(start)  & $q_0$ & $q_1$   & $q_2$   \\
            结束状态(final) & $q_1$ & $q_2$   &     -   \\
            结束状态(final) & $q_2$ & -       & $q_1$   \\
            \bottomrule%\hline
        \end{tabular}
    \end{subtable}
    ~% add desired spacing
    \begin{subtable}[t]{0.45\textwidth}
        \centering
        \caption{输出}
        \label{tab:sample_3_result}
        \begin{tabular}{l p{2em}<{\centering} c c }
            \toprule%\hline
            \multirow{2}{*}{状态说明} & \multirow{2}{*}{状态} & \multicolumn{2}{c}{输入字符} \\
            \cline{3-4}      &    & $a$ & $b$  \\
            %\cline{2-9}% partial hline from column i to column j
            \midrule%\hline
            开始状态(start)  & $q_0$ & $q_1$   & $q_1$   \\
            结束状态(final) & $q_1$ & $q_1$   & -   \\
            ---------------& --& - & - \\
            \bottomrule%\hline
        \end{tabular}
    \end{subtable}
\end{table}

图 \ref{fig:DFAMin-3-1} 原本是一个最小的 DFA，由表 \ref{tab:sample_3} 可知，函数算法 “DFA::min\_Hopcroft()” 已经改变了图 \ref{fig:DFAMin-3-1} 的状态数，由 “3” 变到 “2”， 如图 \ref{fig:DFAMinHoop-3} 所示，已经不满足性质 \ref{sec:keepMin}。由此可以认为 FIRE engine 中算法 “DFA::min\_Hopcroft()” 未完成其定义功能。

\begin{figure}[!htbp]
    \centering
    \begin{subfigure}[b]{0.4\textwidth}
        \includegraphics[width=\textwidth]{Min/DFAMinTest-3-1}
        \caption{输入}
        \label{fig:DFAMin-3-1-inside}
    \end{subfigure}
    ~
    \begin{subfigure}[b]{0.4\textwidth}
        \includegraphics[width=\textwidth]{Min/DFAMinTest-3-3}
        \caption{输出}
        \label{fig:DFAMin-3-3-inside}
    \end{subfigure}
    \caption{DFA::min\_Hopcroft 对第 3 个数据输入输出对比}
    \label{fig:DFAMinHoop-3}
  \end{figure}

%对于算法 “DFA::min\_Hopcroft()” 和算法 “DFA::min\_Brzozowski” 的扩展测试见附录。

本小节总结如下
\begin{itemize}
    \item FIRE engine 对于算法 “DFA::min\_Brzozowski” 的实现仍然有不足之处；
    \item FIRE engine 对于算法“DFA::min\_HopcroftUllman()”、“DFA::min\_dragon()”、\\ “DFA::min\_Watson()” 的实现可信度较高；
    \item 除了 DFA::min\_Brzozowski() 算法，其他算法都不能移除 DFA 中的不可达状态；
    \item 移除 DFA::usefulf() 可以用来移除 DFA 中的陷阱状态。
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{DFA::min\_Hopcroft 算法运行结果错误}\label{sec:fixHopcroft}

\subsection{运行结果}

以图 \ref{fig:hopcerror} 中的五个最小的 DFA 为数据，测试结果统计如表 \ref{tab:KeepMinResultofAll} 所示

\begin{table}[!htbp]
    \caption{  }
    \label{tab:KeepMinResultofAll}
    \centering
    \small% fontsize
    \setlength{\tabcolsep}{4pt}% column separation
    \renewcommand{\arraystretch}{1.2}%row space 
    \begin{tabular}{l|p{4em}<{\centering} p{4em}<{\centering} p{4em}<{\centering} p{4em}<{\centering} p{4em}<{\centering} }  %l p{3em}<{\centering} p{3em}<{\centering} p{3em}<{\centering}
        \toprule %\hline 
        算法 & \ref{fig:hoperror--1} & \ref{fig:hoperror--2} & \ref{fig:hoperror--3} & \ref{fig:hoperror--4} &  \ref{fig:hoperror--5}  \\
        \midrule
        DFA::min\_Brzozowski()        & $\surd$ & $\surd$ & $\surd$ & $\surd$     & $\surd$        \\
        DFA::min\_Hopcroft()（修改前） & 中止    & $\times$ & $\surd$ & 中止        & $\surd$       \\
        DFA::min\_Hopcroft()（修改后） & $\times$& $\times$& $\surd$ & $\times$    & $\surd$       \\
        DFA::min\_HopcroftUllman()    & $\surd$ & $\surd$ & $\surd$ & $\surd$     & $\surd$       \\
        DFA::min\_dragon()            & $\surd$ & $\surd$ & $\surd$ & $\surd$     & $\surd$       \\
        DFA::min\_Watson()            & $\surd$ & $\surd$ & $\surd$ & $\surd$     & $\surd$       \\
        \bottomrule%\hline  
    \end{tabular}
\end{table}

对于图 \ref{fig:hoperror--1} ，修改后 Hopcroft 算法输出如下代码 \ref{FCode1}，如图 \ref{fig:hoperror--1-result} 所示。

\begin{lstlisting}[language=bash,label={FCode1},caption={图 \ref{fig:hoperror--1} 输出}]
    DFA
    Q = [0,3)
    S = { 0 }
    F = { 2 }
    Transitions =
    0->{ 'a'->1  'b'->2 }
    1->{ 'a'->2 }
    2->{ 'b'->2 }

    current = -1
\end{lstlisting}
 
对于图 \ref{fig:hoperror--2} ，无论是否修改，Hopcroft均输出代码 \ref{FCode2}，如图 \ref{fig:hoperror--2-result} 所示。
\begin{lstlisting}[language=bash,label={FCode2},caption={图 \ref{fig:hoperror--2} 输出}]
    DFA
    Q = [0,2)
    S = { 0 }
    F = { 1 }
    Transitions =
    0->{ ['a','b']->1 }
    1->{ 'b'->1 }

    current = -1
\end{lstlisting}

对于图 \ref{fig:hoperror--4} , 修改后 Hopcroft 输出代码 \ref{FCode4}，如图 \ref{fig:hoperror--4-result} 所示。
\begin{lstlisting}[language=bash,label={FCode4},caption={图 \ref{fig:hoperror--4} 输出}]
    DFA
    Q = [0,3)
    S = { 0 }
    F = { 2 }
    Transitions =
    0->{ 'a'->1 }
    1->{ 'b'->2 }
    2->{ 'a'->2 }

    current = -1
\end{lstlisting}


\begin{figure}[!htbp]
    \centering
    \begin{subfigure}[b]{0.7\textwidth}
        \includegraphics[width=\textwidth]{keepMin/hoperror--1-result}
        \caption{$\mathcal{L}=\{aa(b)^* \cup b(b)^*\}$}
        \label{fig:hoperror--1-result}
    \end{subfigure}
    \\
    %\vfill% \vspace{1cm}
    \begin{subfigure}[b]{0.7\textwidth}
        \includegraphics[width=\textwidth]{keepMin/hoperror--2-result}
        \caption{$\mathcal{L}=\{a(b)^* \cup b(b)^*\}$}
        \label{fig:hoperror--2-result}
    \end{subfigure}
    \\
    %\vfill% \vspace{1cm}
    \begin{subfigure}[b]{0.7\textwidth}
        \includegraphics[width=\textwidth]{keepMin/hoperror--4-result}
        \caption{$\mathcal{L}=\{ab(a)^*\}$}
        \label{fig:hoperror--4-result}
    \end{subfigure}
    \caption{Hopcroft 算法的输出 }
    \label{fig:hopcerror-result}
  \end{figure}

  表 \ref{tab:KeepMinResultofAll-hop} 为对比数据

  \begin{table}[!htbp]
    \caption{  }
    \label{tab:KeepMinResultofAll-hop}
    \centering
    \small% fontsize
    \setlength{\tabcolsep}{4pt}% column separation
    \renewcommand{\arraystretch}{1.2}%row space 
    \begin{tabular}{c p{2em}<{\centering}p{2em}<{\centering}ccc }  %l p{3em}<{\centering} p{3em}<{\centering} p{3em}<{\centering}
        \toprule %\hline 
        数据 & $|Q|$ & $|F|$ & $|F|\leq |Q \setminus F|$? & 修改前结果 &  修改后结果  \\
        \midrule
        图 \ref{fig:hoperror--1}        & 5 & 3 & 否 & 中止       & $\times$        \\
        图 \ref{fig:hoperror--2}        & 3 & 2 & 否 & $\times$   & $\times$       \\
        图 \ref{fig:hoperror--3}        & 4 & 2 & 是 & $\surd$    & $\surd$       \\
        图 \ref{fig:hoperror--4}        & 5 & 3 & 否 & 中止       & $\times$       \\
        图 \ref{fig:hoperror--5}        & 5 & 2 & 是 & $\surd$    & $\surd$       \\
        \bottomrule%\hline  
    \end{tabular}
\end{table}

\subsection{错误原因}\label{sec:reason-hopcroft}

以表 \ref{tab:MinData} 中第三个数据，也即图 \ref{fig:DFAMin-3-1} 中的 DFA 为例，此 DFA 在 DFA::min\_Hopcroft 算法中的迭代过程如表 \ref{tab:hopcroftAna} 所示，算法原型见算法 \ref{al:4-8}：

\begin{table}[!htbp]
    \caption{图\ref{fig:DFAMin-3-1}的 DFA 在 DFA::min\_Hopcroft 算法中的迭代过程}
    \label{tab:hopcroftAna}
    \centering
    \footnotesize% fontsize
    \setlength{\tabcolsep}{8pt}% column separation
    \renewcommand{\arraystretch}{1.2}%row space 
    \begin{tabular}{ccccccc|ccc|cc} 
        \toprule%\hline 
        \multirow{2}{*}{$n$} & \multirow{2}{*}{状态} & \multirow{2}{*}{$p$} & \multirow{2}{*}{$q$} & \multirow{2}{*}{$L[q]$} & \multirow{2}{*}{$C$} & \multirow{2}{*}{$r$} & \multicolumn{3}{c|}{$L$} & \multirow{2}{*}{$repr$} & \multirow{2}{*}{$P$}  \\
        \cline{8-10}             &                   &                     &                    &                       &                   &    & 0 & 1 &2 & & \\
        \midrule%\hline
        \multirow{2}{*}{1} & 前 & 0 & 0 & 1 & b & -  & 1 & 0 & 0 & \{0,1\} & \{0\},\{1,2\} \\
                           & 后 & 0 & 0 & 1 & b & -1 & 1 & 0 & 0 & \{0,1\} & \{0\},\{1,2\} \\
        \midrule%\hline
        \multirow{2}{*}{2} & 前 & 1 & 0 & 1 & b & -  & 1 & 0 & 0 & \{0,1\} & \{0\},\{1,2\} \\
                           & 后 & 1 & 0 & 1 & b & -1 & 1 & 0 & 0 & \{0,1\} & \{0\},\{1,2\} \\
        \midrule%\hline
        \multirow{2}{*}{3} & 前 & 0 & 0 & 1 & a & -  & 0 & 0 & 0 & \{0,1\} & \{0\},\{1,2\} \\
                           & 后 & 0 & 0 & 1 & a & -1 & 0 & 0 & 0 & \{0,1\} & \{0\},\{1,2\} \\
        \midrule%\hline
        \multirow{2}{*}{4} & 前 & 1 & 0 & 1 & a & -  & 0 & 0 & 0 & \{0,1\} & \{0\},\{1,2\} \\
                           & 后 & 1 & 0 & 1 & a & -1 & 0 & 0 & 0 & \{0,1\} & \{0\},\{1,2\} \\
        \midrule%\hline
        \multirow{2}{*}{5} & - & - & - & - & - & -  & - & - & - & -- & ------ \\
                           & - & - & - & - & - & -  & - & - & - & -- & ------ \\
        %\midrule
        \bottomrule%\hline 
    \end{tabular}
\end{table}

表 \ref{tab:hopcroftAna} 中各项意义见附录表 \ref{tab:hopcroft} 。
下面对 Hopcroft 算法进行分析：
\begin{enumerate}[(1)]
    \item $Q$ 首先被分为两个等价类，$P=(Q\setminus F) \cup F = \{(0),(1,2)\}$ 。因 $|Q\setminus F|\le |F|$，所以 $L=F\times V$ （算法 \ref{al:4-8} ，语句 2）；
    \item 第一次迭代，取出 $repr$ 第一个元素 $0$，赋值给$p$，此时 $p=0,q=0,C=b$，并且从$L$ 内移除与字符 'b' 相关的转移关系，$Splittable(p,q,c)$不成功\footnote{ 即表 \ref{tab:hopcroftAna} 中 $r=-1$ 时，$Splittable(p,q,c)$不成功。}，不做操作；
    \item 第二次迭代，取出 $repr$ 第一个元素 $1$，赋值给$p$，此时$p=1,q=0,C=b$，$Splittable(p,q,c)$不成功，不做操作；
    \item 第三次迭代，取出 $repr$ 第一个元素 $0$，赋值给$p$，此时$p=0,q=0,C=a$，并且从$L$ 内移除与字符 'b' 相关的转移关系，$Splittable(p,q,c)$不成功，不做操作；
    \item 第四次迭代，取出 $repr$ 第一个元素 $1$，赋值给$p$，此时$p=1,q=0,C=a$，$Splittable(p,q,c)$不成功，不做操作；
    \item 第五次迭代，此时 $L$ 内已经没有转移关系，也就是此时 $L=\emptyset$ （算法 \ref{al:4-8} ，语句 5），迭代结束。此时 $P=\{ \{0\},\{1,2\} \}$ ，于是状态$1$与状态$2$被合并，算法输出如图 \ref{fig:DFAMin-3-3-inside} 所示的结果。算法结束。
\end{enumerate}

\begin{definition}[$Splittable$\cite{watson1993taxonomyb}]
    % $Splittable$ 的定义如下 \\
    % $~~ Splittable(Q_0 ,Q_1, a) \equiv ( \exists ~ p,q : p \in Q_0 \land q \in Q_0 : ( T(p,a) \in Q_1 \not\equiv T(q,a) \in Q_1  ) ) $
    $Splittable$ 的定义如下
    \[  Splittable(Q_0 ,Q_1, a) \equiv ( \exists ~ p,q : p \in Q_0 \land q \in Q_0 : ( T(p,a) \in Q_1 \not\equiv T(q,a) \in Q_1  ) ) \]
\end{definition}



FIRE engine 对 $Splittable$ 的实现如算法 \ref{al:split} 所示。

\begin{algorithm}
    \caption{ DFA::split() }\label{al:split}
    %\small
    \begin{algorithmic}[1]
        \Function{split}{$p,q,c,P$} \Comment{$p \in repr$，$c \in V$ ，$P:= [A]_E$（定义\ref{def:equiv-class}）}
            \Statex \Comment{$q$为 $L$ 中第一个不为 0 的元素的下标}
            \State $part := \emptyset$ 
            \ForAll{$s \in [p]$} \Comment{$[p]$ 为状态 $p$ 所在的等价类}
                \If{ $T(s,c) \ne \emptyset \land T(s,c) \in [q]$ }
                    \State $part := part \cup T(s,c)$
                \EndIf
            \EndFor
            \If {$part \ne [p] \land part \ne \emptyset$}
                \State $otherpiece := [p] \setminus part$
                \If {$p \in part$}
                    \State {\bfseries return} {$part$}
                \Else
                    \State {\bfseries return} {$otherpiece$}
                \EndIf
            \Else
                \State {\bfseries return } {Invalid}
            \EndIf
        \EndFunction
        % \State 其中：
        % \State A 是一个 DFA;
        % \State $P:= [A]_E$
        % \State $[p]$ 为状态 $p$ 所在的等价类 
    \end{algorithmic}
\end{algorithm}

在本例中，由于 $L=(Q \setminus F) \times V$， $L$ 中第一个不为0的元素的下标是 “0” （ $L$ 的意义见附录注释 \ref{rem:means-of-L} ），$q$ 的值即为 L 中第一个不为 0 的元素的下标，此时 $q = 0$ 。依次取出 $repr = \{ 0,1 \}$ 中的元素，对所有的 $c \in V$ 执行 DFA::split() 。当 $p=0 \land q=0 $ 时，$[p]$ 中不能通过任何字符转移到 $[q]$ ；当 $p=1 \land q=0 $ 时，$[p]$ 中不能通过任何字符转移到 $[q]$ 。此时算法运行结束，但是等价类 $\{1,2 \}$ 此时还未被分割，等价类 $\{1,2 \}$ 被合并，成为新自动机（图 \ref{fig:DFAMin-3-3-inside}）中的 $\{ 1\}$ ，于是 Hopcroft 算法输出了错误的结果。

通过对比总结可知，当 $p:p \in F$ ，对所有的 $c:c\in V$ ，使得 $ T(p,c) \notin (Q\setminus F) ) $，且该 DFA 满足 $|F| > |Q \setminus F| $ 时，也即式 \ref{eq:reson-hopcroft}

\begin{equation}\label{eq:reson-hopcroft} 
    (c,p: \forall c \in V \land p \in F \land T(p,c) \notin (Q\setminus F) ) \land |F| > |Q \setminus F| 
\end{equation}
Hopcroft 算法有可能输出错误结果。

\newpage
\subsection{解决方法}\label{subsec:solve-hopcroft}

由第 \ref{sec:reason-hopcroft} 的内容，总结出以下两种解决方案：

\begin{enumerate}[(1)~]
    \item 向 $L$ 中增加二元关系 $F\times V$，也即更改算法 \ref{al:4-8} 中语句 2 $L:= ( \mbox{\textbf{if }} ( |F| \leq |Q \setminus F | ) \mbox{\textbf{then }} \{F\} \mbox{\textbf{else }} \{ Q \setminus F \} \mbox{\textbf{end if }} ) \times V $ 为 $ L:= (Q\times V) \cup F\times V $；
    \item 构造完全 DFA，使得对于满足关系 $|F| > |Q \setminus F|$ 的非完全 DFA中，存在 $ c \in V $ 使得 $ p \in F \land T(p,c) \in (Q\setminus F) $；
\end{enumerate}

\subsubsection{具体做法}

{\bfseries 方案 1}

对于方案 1 ，对 FIRE engine 的具体更改如下

\begin{lstlisting}[language=C++,label={lst:min-hop},caption={min-hop.cpp}]
    if (F.size() <= (Q.size() - F.size()))   //移除
	{                                        //移除
		repr.intersection(F);                //移除
	}                                        //移除
	else                                     //移除
	{                                        //移除
		repr.remove(F);                      //移除
	}                                        //移除
\end{lstlisting}

Hopcroft 算法（算法 \ref{al:4-8}）的正确性已经被证实过\cite{Hopc71,HUFFMAN1954161,yingjie2009describing}，该算法也是时间复杂度最优的版本，按照方案 1 更改将会导致算法的时间复杂度增加，并不符合算法本意。

方案 1 更改后的算法实际上是 Bruce William Watson 的论文中提及的未优化的算法，该算法如算法 \ref{al:hopcroft-old} 所示。

\begin{algorithm}
    \caption{ \cite{watson1993taxonomyb} }\label{al:hopcroft-old}
    \small%\footnotesize
    \begin{algorithmic}[1]
        \State $P:=[Q]_{E_0}$;
        \State $L:=P\times V$;
        \State $\{ \mbox{恒有：} [Q]_E \sqsubseteq P \sqsubseteq [Q]_{E_0} \land L \subseteq (P \times V) $
        \State \quad $ \land L \supseteq  \{ (Q_1,a) : (Q_1,a) \in (P \times V) \land ( \exists Q_0 : Q_0 \in P : Splittable (Q_0,Q_1,a) ) \} $
        \State \quad $ \land (\forall Q_0,Q_1,a:Q_0 \in Q \land (Q_1,a) \in L : \neg Splittable (Q_0,Q_1,a)) \Rightarrow (P=[Q]_E) \} $
        \Repeat{$L \not= \emptyset \longrightarrow$}
            \State $ \mbox{\textbf{let }} Q_1,a:(Q_1,a) \in L $;
            \State $ P_{old} := P $;
            \State $ L := L \setminus \{ (Q_1,a) \} $;
            \State $ \{ \mbox{恒有:} [Q]_E \sqsubseteq P \sqsubseteq P_{old} \} $
            \For {$Q_0 : Q_0 \in P_{old} \land Splittable (Q_0,Q_1,a)$}
                \State $ Q'_0 := \{ p:p \in Q_0 \land T(p,a) \in Q_1 \} $;
                \State $ P:= P \setminus \{ Q_0 \} \cup \{ Q_0 \setminus Q'_0,b \} $;
                \For {$b:b \in V$}
                    \If{$(Q_0,b) \in L$}
                       $ L := L \setminus \{ (Q_0,b) \} \cup \{ (Q'_0,b),(Q_0, \setminus Q'_0,b ) \} $
                    \ElsIf{$(Q_0,b) \not\in L$}
                        $ L := L \cup \{ (Q'_0,b),(Q_0, \setminus Q'_0,b ) \}$
                    \EndIf
                \EndFor
            \EndFor
            \State $ \{ (\forall Q_0,Q_0 \in P : \neg Splittable(Q_0,Q_1,a)) \} $
        \Until $\{ P = [Q]_E \}$
    \end{algorithmic}
\end{algorithm}

\begin{remark}
    对于算法 \ref{al:hopcroft-old} 中语句 2 ，在算法的第一步，将 $Q$ 分为两个等价类 $ P = \{ \{Q\setminus F\}, F \}$，对应方案 1 的更改方法。
\end{remark}

并且 Bruce William Watson 也对 Hopcroft 算法（算法 \ref{al:4-8}）中语句 2 进行了详细的说明，Bruce William Watson 已经指出，由于一开始就将 $Q$ 分割成了 $P=[Q]_{E_{0}}=\{Q \backslash F, F\}$ ,所以只需要相对于 $(Q \backslash F, b)$ or $(F, b)$ （对所有的 $b \in V $）进行等价类分割即可\cite{Hopc71,watson1993taxonomyb}。所以方案 1 并不是一个比较好的方法。

按照方案 1 更改后 DFA::min-Hopcroft 通过样例测试，如表 \ref{tab:KeepMinResultofAll-fix1} 所示。

\begin{table}[!htbp]
    \caption{  }
    \label{tab:KeepMinResultofAll-fix1}
    \centering
    %\small% fontsize
    \setlength{\tabcolsep}{6pt}% column separation
    \renewcommand{\arraystretch}{1.2}%row space 
    \begin{tabular}{l| ccccc }  %l p{3em}<{\centering} p{3em}<{\centering} p{3em}<{\centering}
        \toprule %\hline 
        算法 & \ref{fig:hoperror--1} & \ref{fig:hoperror--2} & \ref{fig:hoperror--3} & \ref{fig:hoperror--4} &  \ref{fig:hoperror--5}  \\
        \midrule
        DFA::min\_Brzozowski()        & $\surd$ & $\surd$ & $\surd$ & $\surd$     & $\surd$        \\
        DFA::min\_Hopcroft()（方案1修改前） & $\times$    & $\times$ & $\surd$ & $\times$        & $\surd$       \\
        DFA::min\_Hopcroft()（方案1修改后） & $\surd$& $\surd$& $\surd$ & $\surd$    & $\surd$       \\
        DFA::min\_HopcroftUllman()    & $\surd$ & $\surd$ & $\surd$ & $\surd$     & $\surd$       \\
        DFA::min\_dragon()            & $\surd$ & $\surd$ & $\surd$ & $\surd$     & $\surd$       \\
        DFA::min\_Watson()            & $\surd$ & $\surd$ & $\surd$ & $\surd$     & $\surd$       \\
        \bottomrule%\hline  
    \end{tabular}
\end{table}

{\bfseries 方案 2}

FIRE engine 中没有实现构造完全 DFA 的算法。

本文提出一个用于在 FIRE engine 中构造一个完全 DFA 的算法，如算法 \ref{al:complete-M} 所示。

\begin{algorithm}
    \caption{ 构造完全 DFA 的算法 }\label{al:complete-M}
    %\small%\footnotesize
    \begin{algorithmic}[1]
        \Require 一个DFA $M=\{Q,V,T,E,S,F\}$
        \Ensure 一个与 $M$ 等价的完全 DFA $M'=\{Q',V,T',E,S,F\}$
        \Statex \Comment{$M$ 与 $M'$ 满足定义 \ref{def:isom}}
        \Function{complete}{}
            \State {$flag:=false$};
            \ForAll {$p \in Q \land flag=false$}
                \ForAll{$c \in V \land flag=false$}
                    \If{ $ T(p,c) = \emptyset $ }
                         {$flag:=true$}
                    \EndIf
                \EndFor
            \EndFor
            \If{flag=true}
                \State $usefulf(M)$; \Comment{移除 $M$ 中的陷阱状态}
                \State $usefuls(M)$; \Comment{移除 $M$ 中的开始不可达状态}
                \ForAll {$p \in Q \land flag=false$}
                    \ForAll{$c \in V \land flag=false$}
                        \If{ $ T(p,c) \not= \emptyset $ }
                            $T':= T' \cup T'(g(p)\times c \times g(T(p,c)))$
                        \Else
                            $~~T' := T' \cup T'(g(p)\times c \times \mbox{\bfseries sink})$
                        \EndIf
                    \EndFor
                \EndFor
            \EndIf
        \EndFunction
    \end{algorithmic}
\end{algorithm}

\begin{remark}
    构造完全自动机本应该仅对于满足 $ p,c:p\in Q \land c \in V: T(p,c)= \emptyset$ 的状态，增加转移关系 $T(p \times c \times sink)$ , $p,c$ 满足 $ p,c:p\in Q \land c \in V $。但是考虑到原本的 DFA 中可能有多个不可达状态，若仅仅构造完全 DFA ，DFA 的大小仍然会变大，所以应该在构造完全 DFA 前，移除 DFA 中的不可达状态，然后再构造完全 DFA 。这样构造出来的完全 DFA ，仅比原本的 DFA 移除不可达状态后多一个状态（陷阱状态）。有利于缩短算法的运行时间。
    
    公式表达形式为（若原 DFA 含不可达状态）
    \begin{equation}
        |Complete( useful (M))| -  |useful (M)| = 1
    \end{equation}
\end{remark}

\begin{remark}
    对于接受同一个 $\mathcal{L}$ 的最小的但不完全 DFA $M$ 和最小且完全的 DFA $M_{\mathcal{C}}$， $M_{\mathcal{C}}$ 比 $M$ 多一个陷阱状态（Sink State）\cite{watson1993taxonomyb}。
\end{remark}

需要留意的是，FIRE engine 中仅实现了用于去除陷阱状态的函数 DFA::usefulf() ，而没有实现用于去除开始状态的函数，虽然不可达状态并不会影响 DFA 接受的 $\mathcal{L} $。但是不可达状态同样会影响算法的时间复杂度。

给出一个用于在 FIRE engine 内去除 DFA 的开始不可达状态的算法

\begin{algorithm}
    \caption{ 移除 DFA 中开始不可达状态的算法 $usefuls$ }\label{al:usefuls}
    %\small%\footnotesize
    \begin{algorithmic}[1]
        \Require 一个含有开始不可达状态的 DFA $M=\{Q,V,T,E,S,F\}$
        \Ensure 一个与 $M$ 等价的完全 DFA $M'=\{Q',V,T',E,S',F'\}$
        \Statex \Comment{$M$ 与 $M'$ 满足定义 \ref{def:isom}}
        \Function{usefuls}{}
            \State $Q' := SReachable(M) $
            \ForAll{$p \in Q'$}
                \ForAll {$c \in V$}
                    \If {$T(p,c) \ne \emptyset$}
                        \State $ T' := T' \cup T'(p\times c \times q) $
                        \State $ V' := V' \cup c $
                    \EndIf
                \EndFor
            \EndFor
            \State $S':=Q' \cap S$
            \State $F':=Q' \cap F$
        \EndFunction
    \end{algorithmic}
\end{algorithm}

同样的， FIRE engine 中并没有实现 $SReachable()$ ， 本文给出这样一个算法

\begin{algorithm}
    \caption{ $SReachable$ }\label{al:SReachable}
    \small%\footnotesize
    \begin{algorithmic}[1]
        \Require 一个 DFA $M=\{Q,V,T,E,S,F\}$
        \Ensure $SReachable(M)$
        \Statex %\Comment{$M$ 与 $M'$ 满足定义 \ref{def:isom}}
        \Function{SReachable}{}
            \State $ Q_1 := S $
            \Repeat
                \State $Q_1 := Q_1 \cup Q_2 $
                \ForAll{$p \in Q_1$}
                    \ForAll {$ c \in V $}
                        \If{$ T(p,c) \ne \emptyset$}
                            $ Q_2 := Q_2 \cup T(p,c)  $
                        \EndIf
                    \EndFor
                \EndFor
            \Until{$Q_1 = Q_2$}
            \State {\bfseries return} {~~$Q_2$}
        \EndFunction
    \end{algorithmic}
\end{algorithm}

{\bfseries 代码实现}

算法 \ref{al:complete-M} 的代码实现见附录 \ref{sec:complete-imp} 。

算法 \ref{al:usefuls} 的代码实现见附录 \ref{sec:usefulfs-imp} 。

算法 \ref{al:SReachable} 的代码实现见附录 \ref{sec:SReachable-imp} 。