%!TEX root = ../Demo.tex
\chapter{代码}

\section{实例化 DFA 对象示例代码}

一个实例化 DFA 类的例子如代码 \ref{lst:DFASample} 所示。代码 \ref{lst:DFASample} 中执行了 DFA::usefulf() 函数，去除多余的状态，让输出数据与原始数据相对应。代码 \ref{lst:DFASample} 对应的 DFA 为图 \ref{fig:keepMin-1-nonTheState} 。


\lstset{style=mystyle}
\begin{lstlisting}[language=C++,label={lst:DFASample},caption={实例化DFA示例}]
#include"DFA.h"
#include<iostream>
int main()
{
    DFA_components dfa_com1;

    // StateSet S  开始状态集
    dfa_com1.S.set_domain(4);
    dfa_com1.S.add(0);

    // StateSet F  结束状态集
    dfa_com1.F.set_domain(4);
    dfa_com1.F.add(3);

    // StatePool Q 
    int i = 10;
    while (i--)
    {
        dfa_com1.Q.allocate();
    }

    // DTransRel T transition             
    dfa_com1.T.set_domain(4);
    dfa_com1.T.add_transition(0, '0', 1);
    dfa_com1.T.add_transition(1, '0', 2);
    dfa_com1.T.add_transition(2, '0', 3);
    dfa_com1.T.add_transition(3, '0', 3);
    dfa_com1.T.add_transition(0, '1', 0);
    dfa_com1.T.add_transition(1, '1', 0);
    dfa_com1.T.add_transition(2, '1', 0);
    dfa_com1.T.add_transition(3, '1', 0);

    DFA dfa1(dfa_com1);
    std::cout<<dfa1<<std::endl;
    return 0;
}
\end{lstlisting}

\section{$SReachable$ 实现代码}\label{sec:SReachable-imp}

类 DTransRel 为 FIRE engine 里面类 DFA 中存储转移关系的类，但是这个类并没有实现 $SReachable$ （见定义 \ref{def:rechable-state}）。本文提出实现 $SReachable$ 的算法（算法 \ref{al:SReachable}），本小节为代码实现。

本文为 FIRE engine 增加的 $SReachable$ 功能声明为代码 \ref{lst:SReachable-def} 中的 “StateSet closure(const StateSet\& r) const;” ，传入参数 $r=S$。

\lstset{style=mystyle}
\begin{lstlisting}[language=C++,label={lst:SReachable-def},caption={文件 DTransRel.h}]
class DTransRel :public StateTo<DTrans>
{
public:
    ……
    // What are all States reachable from r?           // 新增
    StateSet closure(const StateSet& r) const;         // 新增
    ……
}
\end{lstlisting}

本文为 FIRE engine 增加的 $SReachable$ 功能定义如代码 \ref{lst:SReachable-imp} 所示。

\lstset{style=mystyle}
\begin{lstlisting}[language=C++,label={lst:SReachable-imp},caption={文件 DTransRel.cpp}]
// What are all States reachable from r?
StateSet DTransRel::closure(const StateSet& r) const
{
    StateSet result(r);
    StateSet intermediate;
    StateSet temp;
    intermediate.set_domain(domain());
    temp.set_domain(domain());

    while (result != intermediate)
    {
        result.set_union(intermediate);
        intermediate.clear();
        State st;
        for (result.iter_start(st); !result.iter_end(st); result.iter_next(st))
        {
            StateSet temp = lookup(st).range(domain());
            intermediate.set_union(temp);
            temp.clear();
        }
    }

    return(result);
}
\end{lstlisting}

\section{$useful_s$ 实现代码}\label{sec:usefulfs-imp}

$useful_s$ 用来移除 DFA 中的开始不可达状态（见变换 \ref{trans:usefuls}），但是 FIRE engine 中并没有实现这个功能，本文提出相应的算法（见算法 \ref{al:usefuls}）。

\begin{remark}
    Bruce William Watson 在他的论文 \cite{watson1993taxonomyb} 中有对 $useful_s$ 的描述，但是在 FIRE engine 内没有实现；对 $useful_f$ 的描述出现在他的论文\cite[注释 2.39]{watson1993taxonomya}，并且在 FIRE engine 中实现了这个功能，也即函数 DFA::usefulf() 。
\end{remark}

与上一节内容类似，在文件 DFA.h 内添加功能对应的函数的声明，如代码所示

\begin{lstlisting}[language=C++,label={lst:usefuls-def},caption={文件 DFA.h}]
class DFA : virtual public FAabs
{
public:
    ……
    // remove any States that cannot reach from a start State // 新增
	DFA& usefuls();                                           // 新增
    ……
}
\end{lstlisting}

在文件 DFA.cpp 中新增功能对应的函数的定义如下

\begin{lstlisting}[language=C++,label={lst:usefuls-imp},caption={文件 DFA.cpp}]
DFA & DFA::usefuls()
{
    assert(class_invariant());
    StateSet sreachable(T.closure(S));
    StateTo<State> newnames;
    newnames.set_domain(Q.size());


    // All components will be constructed into a special structure :
    DFA_components ret;
    State st;
    for (st = 0; st < Q.size(); st++)
    {
        // If this is a Usefulf State, carry it over by giving it a name
        // in the new DFA.
        if (sreachable.contains(st))
        {
            newnames.map(st) = ret.Q.allocate();
        }
        else
        {
            newnames.map(st) = Invalid;
        }
    }


    // It is possible that nothing needs to be done(ie.the all States were
    // already F useful).
    if (Q.size() != ret.Q.size())
    {
        ret.T.set_domain(ret.Q.size());
        ret.F.set_domain(ret.Q.size());

        CRSet a;
        for (st = 0; st < Q.size(); st++)
        {
            // Only construct the transitions if st is final reachable.
            if (sreachable.contains(st))
            {
                a = T.out_labels(st);
                State stprime(newnames.lookup(st));

                CharRange b;
                int it;
                // Construct the transitions.
                for (it = 0; !a.iter_end(it); it++)
                {
                    b = a.iterator(it);
                    State stdest;
                    stdest = newnames.lookup(T.transition_on_range(st, b));
                    if (stprime != Invalid && stdest != Invalid)
                    {
                        ret.T.add_transition(stprime, b, stdest);
                    }
                }
                // This may be a final State.
                if (F.contains(st)) ret.F.add(stprime);
            }
        }
        ret.S.set_domain(ret.Q.size());

        // Add a start State only if the original one was final reachable.
        if (S.not_disjoint(sreachable)) ret.S.add(newnames.lookup(S.smallest()));
        reconstruct(ret);
    }
    assert(class_invariant());
    
    return(*this);
}
\end{lstlisting}

\section{$Complete$ 实现代码}\label{sec:complete-imp}

$Complete$ 用来构造完全 FA （见定义 \ref{def:complete}），由于本文的讨论仅针对 DFA，所以对该定义的实现也仅适用于 DFA。算法描述见算法 \ref{al:complete-M}。

向文件 DFA.h 内增加下内容

\begin{lstlisting}[language=C++,label={lst:complete-def},caption={文件 DFA.h}]
class DFA : virtual public FAabs
{
public:
    ……
    // construct a complete DFA.            // 新增
    // see details Definition 2.15[3]       // 新增
    DFA& complete();                        // 新增

    // is *this a Complete DFA?             // 新增
    int Complete()const;                    // 新增
    ……
}
\end{lstlisting}
    
在文件 DFA.cpp 中新增功能对应的函数的定义如下
    
\begin{lstlisting}[language=C++,label={lst:complete-imp},caption={文件 DFA.cpp}]
// construct a Complete DFA
DFA & DFA::complete()
{
    
    if (!Complete())
    {
        return (*this);
    }

    usefulf();
    usefuls();

    DFA_components ret;

    State q;

    for (q = 0; q <= Q.size(); q++)
    {
        ret.Q.allocate();
    }

    State sink = ret.Q.size()-1;

    CRSet C;
    for (q = 0; q < Q.size(); q++)
    {
        C.combine(T.out_labels(q));
    }

    ret.S.set_domain(Q.size());
    ret.F.set_domain(Q.size());

    ret.S.set_union(S);
    ret.F.set_union(F);

    ret.S.set_domain(ret.Q.size());
    ret.T.set_domain(ret.Q.size());
    ret.F.set_domain(ret.Q.size());

    for (q = 0; q < ret.Q.size(); q++)
    {
        CharRange c;
        for (int i = 0; i < C.size(); i++)
        {
            c = C.iterator(i);
            State stprime = q;
            if (stprime == sink)
            {
                ret.T.add_transition(stprime, c, sink);
                continue;
            }
            State stdest = T.transition_on_range(stprime, c);
            if (stdest != Invalid)
            {
                ret.T.add_transition(stprime, c, stdest);
            }
            else
            {
                ret.T.add_transition(stprime, c, sink);
            }
        }
    }

    reconstruct(ret);
    // TODO: 在此处插入 return 语句
    return (*this);
}

int DFA::Complete() const
{
    State q;
    CRSet C;
    for (q = 0; q < Q.size(); q++)
    {
        C.combine(T.out_labels(q));
    }

    for (q = 0; q < Q.size(); q++)
    {
        CharRange c;
        for (int i = 0; i < C.size(); i++)
        {
            c = C.iterator(i);
            if (T.transition_on_range(q, c) == Invalid)
            {
                return 0;
            }
        }
    }
    return 1;
}
\end{lstlisting}